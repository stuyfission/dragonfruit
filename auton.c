#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S3,     IRSensor3,      sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     IRSensor4,      sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     liftLbottom,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     liftRbottom,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     LED,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C3_1,     leadL,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C3_2,     leadR,         tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servoL,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servoR,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    lockL,                tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    lockR,                tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    auton,                tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-irseeker-v2.h"

void encoderClear(){
	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
	nMotorEncoder[liftLbottom] = 0;
	nMotorEncoder[liftRbottom] = 0;
}
//Intellectual property of Alvin
void tone(int frequency, int durationInMSecs) {
	PlayTone(frequency, durationInMSecs/10);
	wait1Msec(durationInMSecs);
}
//Intellectual property of Alvin
void driveMotors (int encoderTicks, int speed) {
	encoderClear();
	while ((nMotorEncoder[left] < encoderTicks) && (nMotorEncoder[right] < encoderTicks)) {
		motor[left] = speed;
		motor[right] = speed;
	}
	motor[left] = 0;
	motor[right] = 0;
	encoderClear();
}

void quarterTurnClock(int speed){
	encoderClear();
	while ((nMotorEncoder[left] < 1000) && (nMotorEncoder[right] < 1000)){
		motor[left] = -speed;
		motor[right] = speed;
	}
	motor[left] = 0;
	motor[right] = 0;
	encoderClear();
}

void quarterTurnCounterClock(int speed){
	encoderClear();
	while ((nMotorEncoder[left] < 1000) && (nMotorEncoder[right] < 1000)){
		motor[left] = speed;
		motor[right] = -speed;
	}
	motor[left] = 0;
	motor[right] = 0;
	encoderClear();
}

void straightRamp() {
	encoderClear();
	//Locks all the shit
	motor[LED] = 100;
	servo[servoL] = 0;
	servo[servoR] = 255;
	servo[lockL] = 100;
	servo[lockR] = 155;
	servo[auton] = 255;
	motor[liftLbottom] = -100;
	motor[liftRbottom] = 100;
	wait1Msec(1000);
	motor[liftLbottom] = 0;
	motor[liftRbottom] = 0;
	//
	driveMotors(4200, 100);
	//Lead screw lowering
	motor[liftLbottom] = 100;
	motor[liftRbottom] = -100;
	motor[leadL] = -100;
	motor[leadR] = -100;
	wait1Msec(1000);
	motor[liftLbottom] = 0;
	motor[liftRbottom] = 0;
	motor[leadL] = 0;
	motor[leadR] = 0;
}

//IR sensor + ramp autonomous code.
//Intellectual property of Alvin.
//1 foot = 687.55 encoder ticks with current gear ratio.
void irRamp() {
	bool IRBlockDone = false;
	encoderClear();
	motor[LED] = 100;
	servo[servoL] = 0;
	servo[servoR] = 255;
	servo[lockL] = 100;
	servo[lockR] = 155;
	servo[auton] = 255;
	motor[liftLbottom] = -100;
	motor[liftRbottom] = 100;
	wait1Msec(1000);
	motor[liftLbottom] = 0;
	motor[liftRbottom] = 0;
	motor[left] = 20;
	motor[right] = 20;
	encoderClear();
	while ((nMotorEncoder[left] < 4000) && (nMotorEncoder[right] < 4000)) {
		//ramping
		if (SensorValue[IRSensor4] == 7) {
			motor[left] = 16;
			motor[right] = 16;
		}
		if (SensorValue[IRSensor4] == 6) {
			motor[left] = 14;
			motor[right] = 14;
		}
		/*if (((SensorValue[IRSensor4] == 5) && (SensorValue[IRSensor3] == 5)) || (((nMotorEncoder[left] > 2800) && (nMotorEncoder[right] < 2800)) && !IRBlockDone)) {
			motor[left] = 0;
			motor[right] = 0;
			wait1Msec(500);
			servo[auton] = 0;
			wait1Msec(500);
			servo[auton] = 255;
			wait1Msec(500);
			IRBlockDone = true;
			motor[left] = 40;
			motor[right] = 40;
		}*/
		if (((SensorValue[IRSensor4] == 5) && (SensorValue[IRSensor3] == 5)) && !IRBlockDone){
			motor[left] = 0;
			motor[right] = 0;
			wait1Msec(500);
			servo[auton] = 0;
			wait1Msec(500);
			servo[auton] = 255;
			wait1Msec(500);
			IRBlockDone = true;
			motor[left] = 20;
			motor[right] = 20;
		}
	}
	motor[left] = 0;
	motor[right] = 0;
	quarterTurnCounterClock(50);
	driveMotors(2000, 50);
	quarterTurnCounterClock(50);
	driveMotors(2200, 100);
	motor[liftLbottom] = 100;
	motor[liftRbottom] = -100;
	motor[leadL] = -100;
	motor[leadR] = -100;
	wait1Msec(1000);
	motor[liftLbottom] = 0;
	motor[liftRbottom] = 0;
	motor[leadL] = 0;
	motor[leadR] = 0;
	for (int i = 0; i < 3; i++) {
		motor[LED] = 100;
		wait1Msec(250);
		motor[LED] = 0;
		wait1Msec(100);
	}
	for (int i = 0; i < 3; i++) {
		motor[LED] = 100;
		wait1Msec(500);
		motor[LED] = 0;
		wait1Msec(100);
	}
	for (int i = 0; i < 3; i++) {
		motor[LED] = 100;
		wait1Msec(250);
		motor[LED] = 0;
		wait1Msec(100);
	}
}

task main() {
	waitForStart();
	irRamp();
}
